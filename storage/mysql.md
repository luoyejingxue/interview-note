#### MySQL注意事项
	1. 单条查询最后加LIMIT 1 ，停止全表扫描
	2. 对于char(4)或者varchar(4),无论是中文还是英文都是存储四个字符，非四个字节
	3. 如果一个字段为int类型，此类型只有0，1两个状态，不需要建立索引，过度的索引影响更新速度，必须在唯一性较高的字段上建立非聚集索引
	4. 建表时，如果字段能保证非null,那么标记为not null，Mysql对于null需要特殊的标记。使用not null 更节省空间，对于创建索引也有好处
	5. count()会把null统计进去，count(filed)不会统计filed为null的
	6. 在SQL语句的左边用函数，会使得该查询在该字段无法使用缩影，如length(str)
	7. 索引也是需要存储到物理空间，经常增删的表不适合建太多索引，因为索引的委会会很耗时间。
		一张表最多建15个索引，索引的长度越小越好，索引是有序的。如果查询索引字段的大小，会很快
	8. mysql中null不参与比较运算
	9. MySQL InnoDB默认是行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁,
		会使用表级锁把表锁住。
	10. 对于INT(11)的存储，使用的是32位（4个字节）存储空间，设置INT(1)和INT(20)是没有作用的
	11. 把数值设置为非负，可以提升一倍的存储范围
	12. 通常来说，没有必要使用DECIMAL数据类型，可以使用BIGINT,将数据乘以相应的倍数，然后在存储
	13. TIMESTAMP 使用4个字节存储空间，DATETIME使用8个字节存储空间，所以DATETIME范围要大，而且TIMESTAMP的值因时区不同而不同
	14. schema的列不要太多。原因是存储引擎的API工作时需要服务层和存储引擎之间通过行缓冲格式拷贝数据
		,然后通过服务器层将缓冲内容解码成各个列，这个转换过程是非常高的。如果列太多而实际使用的列又很少的话，可能会导致CPU占用高
	15. 大表ALTER TABLE非常耗时，一般步骤是，新建一个空表，在从旧表中查询所有数据插入到新表，然后在删除旧表。
		尤其是当内存不足而表又很大，而且还有很大索引的情况下，耗时更久。
#### MySQL索引
##### 常用规则
	1. 表的主键、外键必须有索引
	2. 数据量超过300的表应该有索引
	3. 经常与其他表进行链接的表，在链接的字段上应该建立索引
	4. 经常出现在where子句中的字段，特别是大表的字段，应该建立索引
	5. 索引应该建立在选择性高的字段上
	6. 索引应该建立在小字段上，对于大的文本字段甚至超长字段，不要建索引
	7. 频繁进行数据操作的表，不要建立太多索引
	8. 删除无用的索引，避免对执行计划造成影响
	9. 复合索引的建立仔细考虑，尽量考虑单字段索引
##### 复合索引考虑
	1. 争取选择复合索引中的主列字段，一般是选择性较好的字段
	2. 复合索引的几个字段是否经常以AND方式出现在where子句中，单字段查询是否极少，如果是，则可以建立复合索引，否则考虑单字段索引
	3. 如果复合索引中包含的字段经常单独出现在where子句中，则分解为多个单字段索引
	4. 如果复合索引的字段超过3个，考虑减少复合的字段
	5. 如果既有单字段索引，又有这几个字段上的复合索引，一般删除复合索引
##### 索引优化
	1. 创建复合索引
		比如
		```sql
		  select * from users where area="beijing" and age=22;
		```
		如果我们在area和age上分别创建单个索引，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了效率，
		但如果在area、age两列上串讲复合索引的话，将带来更改的效率。如果创建（area,age,salary）
		的复合索引，就相当于创建了（area,age,salary）、（area,age）、（area）三个索引，这被成为最佳左前缀。
		因此我们在创建复合索引时应该将最常用作为限制条件的列放在最左边，一次递减
	2. 索引不会包含null值的列
		只要列包含null值都将不会被包含在索引中，复合索引只要有一列含有null值，那么这一列对于此复合索引就无效
	3. 使用端索引
		对串列进行索引，如果可能应该指定一个前缀长度
	4. 排序的索引问题
		mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by 中的列是不会使用索引的
		因此数据库默认排序可以复合要求的情况下不要使用排序操作，尽量不要包含多个列的排序
	5. like语句操作
		不要使用like "%a%",这样不会使用索引，使用like"a%"
	6. 不要在列上进行计算
	7. 不要使用NOT IN
		NOT IN和操作都不会使用索引，将进行全表扫描。NOT IN可以NOT EXISTS代替
#### MySQL锁
	MySQL主要有行级锁和表级锁，不同的存储引擎支持不同的锁机制
	InnoDB存储引擎支持行级锁和表级锁，MyISAM支持表级锁
	表级锁：开销小，加锁快;不会出现死锁（因为MyISAM会一次性获得SQL所需的全部锁）;锁的粒度大，发生锁的几率大,并发能力最低
	行级锁：开销大，加锁慢;会出现死锁；锁的粒度小，发生锁冲突的几率小，并发度高

##### 表级锁(MyISAM)
	1. 锁模式
		表共享读锁（Table Read Lock）和 表独占写锁（Table write Lock）
	2. 如何加锁
		当MyISAM在执行查询语句时，会自动给涉及到表加读锁，在执行更新操作时，会加写锁
	3. 并发插入
		MyISAM存储引擎有个系统变量concurrent_inset，专门用来控制并发插入的行为，可以取0，1，2
		0表示不允许并发插入
		1表示中间没有删除的行时可以在表末尾插入
		2表示总是可以插入
	4. 锁的调度
		在读操作不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求
		在读锁和写锁同时被申请时，优先获得写锁
		写锁会阻塞其他的读操作和写操作

##### 行级锁(InnoDB)
	1. 锁模式
		共享锁和排他锁，对于UPDATE、DELETE、INSERT语句加排他锁
	2. 如何加锁
		可以显示的加锁，用lock in share mode 显示的加共享锁，用for update显示的加排他锁
		如果线程A加了共享锁后，线程B对同一表加了共享锁，那么两个线程需要进行更新操作时会产生死锁
	3. InnoDB行锁的实现方式（索引加锁）
		只有通过索引条件检索数据时，才会使用行级锁，否则使用表级锁
		既是访问不同行的记录，如果使用的是相同的索引键，会发生锁冲突
		如果数据表有多个索引时，可以通过不同的索引锁定不同的行
	4. 间隙锁
		InnoDB支持事务，为了满足隔离级别的要求，InnoDB有个间隙锁，当使用范围查询时，InnoDB
		会给满足key范围要求，但实际并不存在的记录加锁。
		select * from user where id > 100 for update的记录加排他锁，满足这个范围，但不存在的记录，会加间隙锁，这样避免幻读，避免读取的时候插入满足条件的记录
	5. 隔离级别与锁
		一般来说，隔离级别越高，加锁就越严格，这样锁的冲突产生的几率越大
##### 死锁
	MyISAM 是没有死锁问题，他会一次性获得所有的锁
	InnoDB发生死锁后一般能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。
	在应用中，通过如下方式避免死锁：
		1. 在不同的程序会并发的存取多个表时，应尽量约定以相同的顺序访问表，这样会降低死锁的机会
		2. 在程序以批量方式处理数据时，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大的降低出现死锁的可能性

##### 悲观锁和乐观锁
	悲观锁：
		悲观锁是假定其他用户企图访问或者改变数据的可能性很高，因此要先确保获取锁成功后在进行业务操作。
		一锁二查三更新，就是悲观锁。通常悲观锁需要数据库本身的支持，即通过select .... fro update。当数据库执行select for update获取的行锁会在当前事务结束自动释放，因此必须在事务中使用。
```sql
	## 查询库存，主键使用索引，是行级锁
	select number from seckill where seckill_id=? for update
	## 如果库存大于秒杀数，更新，放在一个事务中操作，这是一个悲观锁的例子
	update seckill set number=number-1 where seckill_id=?
```

	乐观锁：
		乐观锁认为其他用户企图改变你正在改变的对象的概率很小，乐观锁只有在你提交所做的改变时才会把对象锁住，当你读取以及改变对象时并不加锁
		乐观锁不需要数据库的特殊支持，一般做法是在需要锁的数据上增加一个版本号或者时间戳，
		乐观锁是否在事务中无所谓，在数据库底层update同一行时是不允许并发的，即数据库每次执行一条update语句时会获取update行锁，直到这一行被成功更新后才会释放。因此在业务操作进行前获取需要锁的数据的当前版本号，然后实际更新数据时再次对比版本号确认与之前的版本，如果相同就没有发生改变，否则认为已被更改过，需要回滚业务操作

```sql
	//获取商品版本号以及剩余数量
	SELECT version,number  FROM seckill WHERE seckill_id=?
	//判断剩余数量是否充足并更新
	UPDATE seckill  SET number=number-?,version=version+1 WHERE seckill_id=? AND version = ? 
	//如果更新数量等于1秒杀成功否则失败
```
```sql
	//直接更新数据，如果count为1秒杀成功否则失败
	UPDATE seckill  SET number=number-1 WHERE seckill_id=? AND number>0
```
#### MySQL事务

##### 事务的基本要素（ACID）
		1. Atomicity(原子性)
			事务开始后所有操作，要么全部完成，要么全部失败。事务执行过程出错，会回滚到事务开始前的状态，所有操作更没有发生一样。也就是事务是一个不可分割的整体，像化学的原子，是物质构成的基本单位

		2. Consistency(一致性)
			事务开始和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没有收到钱

		3. Isolation(隔离性)
			同一时间一个事务请求同一数据，不同的事务之前彼此没有任何干扰。比如A从一张一行卡取钱，在A取钱的过程结束钱，B应该可以向这张卡转账
		4. Durability(持久性)
			事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚
##### 事务并发问题
	1. 脏读
		事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

	2. 不可重复读
		事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据做了更新并提交，导致事务A多次读取同一数据时，结果不一致
	3. 幻读
		事务A读取id小于100的数据时，事务B向id小于100的数据进行了增加或者删除，导致事务A读取出现不一致
	
##### MySQL事务隔离级别
|事务隔离级别|脏读|不可重复读|幻读|
|:-----:| :----: | :-----:|:-----:| 
|读未提交（read-uncommitted）|是|是|是|
|不可重复读（read-committed）|否|是|是|
|可重复读（repeatable-read）|否|否|是|
|串行化（serializable）|否|否|否|

	1. 读未提交
		
	2. 不可重复读

	3. 可重复读（repeatable-read）

	Mysql默认的事务级别是可重复读
	SELECT @@tx_isolation

#### MySQL分表分库

##### 垂直分表分库
	分表：
		大表拆小表，基于列字段进行。一般是表中的字段较多，将不常用的，数据较大的，较长的拆分到扩展表中
	分库：
		针对一个系统中的不同业务进行拆分，比如用户user一个库，商品product一个库，订单order一个库。将数据库放在多态机器上面
##### 水平分表
	分表：
		对于单张表数据量大，按照某种规则，把数据切分到多张表中去
	分库：
		将单张表的数据库切分到多个服务器上去，每个服务器具有相应的库和表，
		能有效的突破单机的IO、连接数、硬件资源的限制

