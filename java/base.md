1. #### Java的三大特性

	封装、继承、多态

	#####	封装：
		把一个对象的属性私有化，同时提供外界可访问属性的方法。

	#####	继承：
		在已有类的基础上，定义一个新类，有用父类非private的属性和方法，
		并增加新的属性和新的方法。对已有的类的扩展和复用

	#####	多态：
		程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，只有在程序运行期间才确定，即一个
		引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，只有在程序运行期间才能确定。

		实现多态的两种形式：继承（多个子类对同一方法进行重写）和接口（实现同一接口并对同一方法进行实现）

2. #### 方法签名
	方法签名由方法名和参数列表（方法的参数和类型）组成
	方法签名不包括方法的返回类型、返回值、访问修饰符

3. #### Override和Overload (重写与重载)
	
	##### Override (重写)
		发生在子类、接口实现类中（重写的是父类或者接口中的方法）
		子类不能重写private方法、不能重写final方法
		重写的方法签名要不变
		方法名、参数列表必须相同
		返回值的范围小于等于父类
		抛出的异常小于等于父类
		访问修饰符范围大于等于父类

	##### Overload (重载)
		发生在同一个类中
		方法名必须相同
		重载的方法签名必然不同
		参数类型、个数、顺序不同
		方法返回值和访问修饰符可以不同
		发生在编译时

4. #### 接口和抽象类
	
	##### 接口
		接口的方法默认是public，在JDK1.8以前（不包括1.8）接口方法不能有实现
		接口中的实例变量默认是final类型，属于该类的
		一个类可以实现多个接口
		一个类实现接口，要实现接口中非default的所有方法（JDK1.8以后有default）
		接口可以被声明，但不能被new实例化
		接口是对行为的抽象
		接口没有构造器
		接口不能有main方法
	
	##### 抽象类
		抽象类的方法修饰符有public、protected、default
		抽象类的实例变量同类一样
		一个类仅能继承一个抽象类
		一个类需要重写抽象类的抽象方法
		不可实例化抽象类，其他与类一样
		抽象类有构造器
		抽象类可以有main方法，并运行它

5. #### 成员变量与局部变量
	|描述|成员变量|局部变量|
	|:-----:| :----: | :-----:|
	|作用范围|属于类|属于方法|
	|修饰|可被访问修饰符、static、final修饰|仅能被final修饰|
	|内存存储方式|由于属于类，对象存在堆内存中|属于方法，存在栈内存中|
	|生存周期|随着类的创建、销毁|随着方法的调用|

6. #### 静态方法与实例方法的区别
	外部调用静态方法，可使用类名.方法名，也可以使用对象名.方法名，但实例方法只可使用后者
	静态方法访问本类的成员时，只允许访问静态成员，实例方法无限制

7. #### == 与 equals
	
	##### ==
		作用是判断两个对象的地址是否相等。即判断两个对象是否为同一个对象。
		基本数据类型==比较的是值，引用数据类型==比较的是内存地址
		对于Integer -128——127（jvm的默认设置）比较的也是值，由于缓存，其他比较的是内存地址
	
	##### equals
		判断两个对象是否相等
		如果没有重写equals方法，那么equals 调用的Object里面的equals方法，里面的实现是使用的==，即同==
		如果重写了equals方法，根据重写的内容，来判断是否相等，我们也可以根据对象的内容来做判断
		注意：String str = "hello";  这样是先在常量池中查找对应的字符串，然后把引用指向该地址
	
	##### 代码示例
	```java
		public class EqualsDemo {
			public static void main(String[] args) {
				String a = new String("ab"); // a 为一个引用
				String b = new String("ab"); // b为另一个引用,对象的内容一样
				String aa = "ab"; // 放在常量池中
				String bb = "ab"; // 从常量池中查找
				System.out.println("aa==bb -> "+(aa==bb));// true

				System.out.println("a==b -> "+(a==b));// false，非同一对象
				System.out.println("a EQ b -> " + (a.equals(b)));// true
				System.out.println("42 == 42.0 -> "+(42==42.0));// true

				Integer i0 = 50;
				Integer i1 = 50;
				Integer i2 = new Integer(50);

				Integer i3 = 300;
				Integer i4 = 300;

				System.out.println("i0==i1 -> "+(i0==i1));//自动拆装箱时，会使用Integer.valueof()创建，如果在整数缓存中直接返回值，否则创建对象,返回true
				System.out.println("i3==i4 -> "+(i3==i4));// false，非同一对象
				System.out.println("i1==i2 -> "+(i1==i2));//由于默认的IntegerCache的值是从-128——127,而300不再其中，所以返回的是对象，对象不相等，返回false
			}
		}
	```

8. #### hashCode() 与equals()
	##### hashCode()
		hashCode是获取哈希码，实际上是返回一个int整数。哈希码的作用是确定该对象在哈希表中的索引位置
		在hashSet、hashMap中对象可以根据hashCode的值来判断对象加入的位置。如hashSet中不允许重复数据出现，可以先根据对象的hashCode值索引位置，如果该位置没有对象，那么就直接写入，如果有对象，则根据equals比较对象。
		hashCode默认会对堆上的对象产生独特的值，在com.icehand.**@2,后面的值

	##### 重写equals时hashCode的注意事项
		1.如果两个对象相等，则hashCode一定也相同
		2.如果两个对象相等，则equals返回一定是true
		3.两个对象hashCode相等，并不代表两个对象相等
		4.equals方法重写了，必须要重写hashCode，不然在用到hasCode的里面HashMap、HashSet里面
		  对重复放进去的对象，也区分为不同的对象（虽然调用equals方法返回的是true）

9. #### 自动装箱和自动拆箱
		装箱：把基本类型用它们对应的应用类型包装起来
		拆箱：将包装类型转换为基本数据类型

10. #### JAVA八大基本数据类型
	Java的八大基本类型：int、byte、long、short、float、char、double、boolean
	字符型：char
	布尔型：boolean
	数值类型：byte、short、int、long、float、double
	整数类型：byte、short、int、long
	浮点类型：float、double

	|类型|占位|最大存储|范围|
	|:-----:| :----: | :-----:|:-----:|
	|byte|8bit|255|-128 —— 127|
	|short|16bit|65536|-32768 —— 32767|
	|int|32bit|2的32次方减1|负的2的31次方到正的2的31次方减1|
	|long|64bit|2的64次方减1|负的2的63次方到正的2的63次方减1|
	|float|32bit||2^149 —— 2^128 -1|
	|double|64bit||4.9E-324（2^-1074）—— 2^1024 -1|
	|char|16bit|利用unicode存储|0 - 2^16 - 1|
	|boolean|1bit或31bit,依据jvm标准||

11. #### 值传递与引用传递
	值传递：实际参数把它的值传递给对应的形式参数，函数接收的是原始值的一个copy,此时内存中存在两个相等的基本类型，即实际参数与形式参数
		后面的方法对形式参数进行修改，对原始值都不会造成影响

	引用传递：方法调用时，实际参数的引用地址传递给方法相应的形参，函数接收的是实际参数的内存地址
		在方法执行时，形参和实际参数相同，都指向同一块内存地址，方法执行对引用的操作会影响到实际的参数。

12. #### 程序、进程、线程
	##### 程序
		程序是含有指令和数据的文件，被存储在磁盘或者其他的数据存储设备中。程序是静态的代码
	##### 进程
		进程是程序的一次执行过程，是系统运行程序的基本单位。进程是动态的。
		系统运行程序既是从一个进程的创建到销毁的过程。
		每个进程拥有某些系统资源如CPU时间、内存空间、文件等
	##### 线程
		线程是资源分配的最小单位，是CPU调度的最小单位，是进程执行的基本单位。一个进程可以拥有多个线程
		多个线程可以共享同一资源
13. #### 线程的状态
	1.新建
		新疆一个线程对象
	2.可运行
		线程创建成功，进入可运行线程池中，等待线程调度，获取CPU的使用权
	3.运行中
		线程获取到CPU的使用权，执行对应的代码段
	4.阻塞
		线程由于某种原因，放弃了CPU的使用权，让出了CPU的时间片，进入阻塞状态
		等待阻塞：运行中的线程执行o.wait()方法，jvm会把线程放入等待队列中,直到被o.notify()/notifyAll()唤醒
		同步阻塞：运行中的线程获取对象的同步锁时，若该同步锁被其他线程占用，则JVM会把该线程放入锁池中
		其他阻塞：运行中的线程执行sleep或者join()或者发起IO请求,JVM会把线程置为阻塞状态
	5.死亡
		线程执行结束或者因异常退出，线程的生命周期结束，死亡的线程不可复生
	6.[图示](thread.jpg)